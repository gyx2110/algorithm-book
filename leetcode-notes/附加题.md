61. [旋转链表](https://leetcode-cn.com/problems/rotate-list/)

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

**示例 1:**

输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL

解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL
```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(head==null || head.next==null || k ==0){
            return head;
        }
        //说是循环旋转，但其实本质上是将尾部向前数
        //第K个元素作为头，原来的头接到原来的尾上
        ListNode node = head;
        int length = 1;
        //求长度
        while(node.next!=null){
            length++;
            node = node.next;
        }
        
        k %= length;
        k = length - k;
        
        //改成循环链表
        node.next = head;
        
        //走n-k步到新的头结点
        node = head;
        ListNode pre = null;
        while(k-->0){
            pre = node;
            node = node.next;
        }
        pre.next = null;
        return node;
    }
}
```
63. [不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
```java
class Solution {
    public static int uniquePathsWithObstacles(int[][] map) {
		int m = map.length;
		int n = map[0].length;
		int[][] dp = new int[m][n];
        //对于第一行或第一列出现1后面的都为0
		for (int i = 0; i < m; i++) {
			if (map[i][0] == 1) {
				break;
			}
			dp[i][0] = 1;
		}
		for (int i = 0; i < n; i++) {
			if (map[0][i] == 1) {
				break;
			}
			dp[0][i] = 1;
		}
        //一般情况 map[i][j]=1，则dp[i][j]=0
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (map[i][j] == 1) {
					dp[i][j] = 0;
				} else {
					dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
				}
			}
		}
		return dp[m - 1][n - 1];
	}
}
```

