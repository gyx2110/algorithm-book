4、148、207、279、287

3. [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

**示例 1:**

>输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

**示例 2:**

>输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

**示例 3:**

>输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

**备注:**

>4.18税友笔试遇到这题
```python
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        length = len(s)
        if length ==0:
            return length
        i,j=0,0
        w = []
        res = 0
        while i<length and j<length:
            if s[j] in w:
                w.remove(s[i])
                i+=1
            else:
                w.append(s[j])
                j+=1
                res = max(res,j-i)
        return res
```


4、

5. [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

**示例 1：**

>输入: "babad"
输出: "bab"

注意: "aba" 也是一个有效答案。

**示例 2：**

>输入: "cbbd"
输出: "bb"

**思路：**

`dp[i][j]`表示s[i..j]是否回文 是则为true，否则为false
- `s[i]=s[j]` 则 `dp[i][j]`取决于s[i+1..j-1]是否是回文串
- `s[i]!=s[j]` 则`dp[i][j]`=false

基本情况
- `dp[i][i]=true`
- `dp[i][i+1]=s[i]==s[i+1]`

```python
class Solution(object):
    def longestPalindrome(self, s):
        length = len(s)
        if length < 2:
            return '' if length==0 else s
        dp = [[0] * length for i in range(length)]
        start = 0
        end = 0
        # 枚举子串的长度
        for l in range(1,length+1):
            low = 0
            while low+l-1 < length:
                high = low + l -1         # high-low<=1为BaseCase
                if s[low] == s[high] and (high-low<=1 or dp[low+1][high-1]):
                    dp[low][high] = 1
                    start = low
                    end = high
                low+=1
        return s[start:end+1]
        
```

Manacher算法
```java
class Solution {
	public static String longestPalindrome(String s) {
		return manacher(s);
	}

	// #A#B#C#C#E#
	public static char[] manacherString(String str) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < str.length(); i++) {
			sb.append("#");
			sb.append(str.charAt(i));
		}
		sb.append("#");
		return sb.toString().toCharArray();
	}

	public static String manacher(String str) {
		if (str == null || str.length() == 0) {
			return "";
		}
		char[] charArr = manacherString(str);
		int[] radius = new int[charArr.length];
		int C = -1;
		int R = -1;
		int max = 0;
		int rc = 0;
		for (int i = 0; i != charArr.length; i++) {
			// 区分了当i在回文半径里外时
			radius[i] = R > i ? Math.min(radius[2 * C - i], R - i) : 1;
			while (i + radius[i] < charArr.length && i - radius[i] > -1) {
				// 以点i为中心往外扩
				if (charArr[i + radius[i]] == charArr[i - radius[i]])
					radius[i]++;
				else {
					break;
				}
			}
			// 更新最右回文边界
			if (i + radius[i] > R) {
				R = i + radius[i];
				C = i;
			}
			// 当有更大的回文半径时，记录中心点和最大值
			if (radius[i] > max) {
				max = radius[i];
				rc = i;
			}
		}
		String res = String.valueOf(charArr).substring(rc - max + 1, rc + max - 1).replace("#", "");
		return res;
	}
}
```
10. [正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。

- '.' 匹配任意单个字符。
- '*' 匹配零个或多个前面的元素。
- 匹配应该覆盖整个字符串 (s) ，而不是部分字符串。

**说明:**

>s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

**示例 1:**

>输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。

**示例 2:**

>输入:
s = "aa"
p = "a*"
输出: true

解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。

**思路：**

两种情况 ：
- 下一个字符不为*号
 当前字符要相等 或者e[i] = '.'

- 下一个字符为*号
尝试匹配..或者成功返回 或者略过*

```java
class Solution {
	public static boolean isMatch(String s, String p) {
		if (s == null || p == null) {
			return false;
		}
		return isMatchCore(s.toCharArray(), p.toCharArray(), 0, 0);
	}

	// 求s[i..n]和[j..n]是否匹配
	public static boolean isMatchCore(char[] str, char[] exp, int i, int j) {
		// 已经匹配完毕
		if (j == exp.length) {
			return i == str.length;
		}
		// p的下一个字符不是* 则需要当前字符相等 且后面全部匹配
		if (j + 1 == exp.length || exp[j + 1] != '*') {
			return i < str.length && (str[i] == exp[j] || exp[j] == '.') && isMatchCore(str, exp, i + 1, j + 1);
		}

		// p的下一个字符是* 且有s[i] == p[j] || p[j] == '.')
		// p匹配s的1,2,3..直到s[i] ！= p[j]
		while (i < str.length && (str[i] == exp[j] || exp[j] == '.')) {
			if (isMatchCore(str, exp, i, j + 2)) {
				return true;
			}
			i++;
		}
		// 不能用*匹配时略过*
		return isMatchCore(str, exp, i, j + 2);
	}
}
```

55. [跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。

**示例 1:**
输入: [2,3,1,1,4]输出: true

解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。
dp[i]表示i点是否可达

**动态规划：**
- dp[0] = true
- dp[i] 是否可达 取决于0..j..i路径上 j点是否可达且nums[j] >= i-1

```java
class Solution {
    public boolean canJump(int[] nums) {
        if (nums == null || nums.length == 0) {
            return false;
        }
        int len = nums.length;
        boolean[] dp = new boolean[len];
        dp[0] = true;// 初始化
        for (int i = 1; i < len; i++) {
            for (int j = 0; j < i && dp[j]; j++) {
                //j可达，且j位置可走的步数大于等于i,j之间的距离
                //则i是可从j到达的
                if (nums[j] >= i - j) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[len - 1];
    }
}
```
**贪心：**
```python
class Solution(object):
    def canJump(self, nums):
        max_pos = 0
        i=0
        #最后一个位置不要考虑
        while i<len(nums)-1:
            #如果i位置都不能走到
            if max_pos<i:
                return False
            #当前可走的最大步数
            max_pos = max(max_pos,i+nums[i])
            i = i+1
        return max_pos>=len(nums)-1

```

76. [最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)


给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。

**示例：**

>输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
```python
class Solution(object):
    def minWindow(self, s, t):
        ls = len(s)
        lt = len(t)
        if not s or not t or ls<lt:
            return ''
        min_size = ls + 1
        l = r = 0
        start=0
        end = ls-1
        map = {}
        #对t中的字符计数
        for c in t:
            map[c] = map.get(c,0)+1
        match = 0
        while r<ls:
            map[s[r]] = map.get(s[r],0)-1
            #如果当前遇到的字符在map中出现过，则匹配数+1
            match = match+1 if map[s[r]]>=0  else match
            #当匹配完成时窗口左滑
            if match==lt:
                #尝试左滑窗口 对之前遇到的字符出窗口
                while map[s[l]]<0:
                    map[s[l]]+=1
                    l+=1
                if min_size > r - l + 1:
                    min_size = r - l +1
                    start = l
                    end = r
            r+=1
        return '' if min_size>ls else s[start:end+1]
```

84. [柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
求在该柱状图中，能够勾勒出来的矩形的最大面积。

```python
class Solution(object):
    def largestRectangleArea(self, heights):
        s = []
        res = 0
        # 可以保证在最后总会计算
        heights.append(0)
        for i in range(len(heights)):
            # 当前位置小于栈顶位置时计算
            while s and heights[s[-1]] > heights[i]:
                h = heights[s.pop()]
                # i-s[-1]-1 和 i 是底
                area = h * (i-s[-1]-1 if s else i)
                res = max(res,area)
            s.append(i)
        return res
```

128. [最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 O(n)。

**示例:**

>输入: [100, 4, 200, 1, 3, 2]
输出: 4

解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。

**思路：**
>将num添加map中时考察map中是否有num-1或num+1，如果有则要更新`左右边界`在map中的长度

```python
class Solution(object):
    def longestConsecutive(self, nums):
        map = {}
        res = 0
        for num in nums:
            if num not in map:
                lb = num - map.get(num-1,0)
                rb = num + map.get(num+1,0)
                length = rb - lb + 1
                # k-v:num->length
                map[num] = length
                map[lb] = length
                map[rb] = length
                res = max(res,length)
        return res
```
139. [单词拆分](https://leetcode-cn.com/problems/word-break/)

给定一个非空字符串s和一个包含非空单词列表的字典 wordDict，判定s是否可以被空格拆分为一个或多个在字典中出现的单词。

**说明：**

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。

**示例 1：**

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true

解释: 返回 true因为"leetcode"可以被拆分成 "leet code"。

**思路：**

dp[i]表示s前i-1个字符能否被wordDict拆分
- dp[0] = true
- dp[i] = dp[j] & s[j:i) in wordDict(j in [0,i) ) 任意一个j满足即可

```python
class Solution(object):
    def wordBreak(self, s, wordDict):
        len_s = len(s)
        dp = [0] * (len_s+1)
        dp[0] = 1
        for i in range(1,len_s+1):
            for j in range(i):
                if dp[j] and s[j:i] in wordDict:
                    dp[i] = 1
                    break
        return dp[-1]
```

148、

152. [乘积最大子序列](https://leetcode-cn.com/problems/maximum-product-subarray/)

给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

**示例 1:**

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。

**示例 2:**

输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
以nums[i]结尾的乘积最大值可能来自三种情况：
- nums[i]
- min * nums[i] `(当nums[i]<0)`
- max *nums
```python
class Solution(object):
    def maxProduct(self, nums):
        if not nums or len(nums) == 0:
            return 0
        _min = _max = res = nums[0]
        for num in nums[1:]:
            minEnd = _min*num
            maxEnd = _max*num
            _min = min(min(minEnd,maxEnd),num)
            _max = max(max(minEnd,maxEnd),num)
            res = max(res,_max)
        return res
```

207、

208、[实现前缀树](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

实现一个 Trie (前缀树)，包含insert,search, 和 startsWith 这三个操作。

**示例:**

Trie trie = new Trie();

trie.insert("apple");

trie.search("apple");   // 返回 true

trie.search("app");     // 返回 false

trie.startsWith("app"); // 返回 true

trie.insert("app");   

trie.search("app");     // 返回 true

**说明:**

你可以假设所有的输入都是由小写字母 a-z 构成的。

保证所有输入均为非空字符串。
```java
public class Trie {

	private TrieNode root;

	public static class TrieNode {
		public int end;
		public TrieNode[] next;

		public TrieNode() {
			end = 0;
			next = new TrieNode[26];
		}
	}

	public Trie() {
		root = new TrieNode();
	}

	public void insert(String word) {
		char[] chs = word.toCharArray();
		TrieNode node = root;
		int index = 0;
		for (int i = 0; i < chs.length; i++) {
			index = chs[i] - 'a';
			if (node.next[index] == null) {
				node.next[index] = new TrieNode();
			}
			node = node.next[index];
		}
		// 以当前结点结尾的单词数+1
		node.end++;
	}

	public boolean search(String word) {
		TrieNode node = traversal(word);
		if (node == null || node.end == 0) {
			return false;
		}
		return true;
	}

	public boolean startsWith(String pre) {
		return traversal(pre) != null;
	}

	// 返回word在树中的最后一个结点，或者null
	private TrieNode traversal(String word) {
		char[] chs = word.toCharArray();
		TrieNode node = root;
		int index = 0;
		for (int i = 0; i < chs.length; i++) {
			index = chs[i] - 'a';
			if (node.next[index] == null) {
				return null;
			}
			node = node.next[index];
		}
		return node;
	}
}
```

279、
287、

300. [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**

>输入: [10,9,2,5,3,7,101,18]
输出: 4 

解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。

```java
	class Solution {
		public int lengthOfLIS(int[] arr) {
			if (arr == null || arr.length == 0) {
				return 0;
			}
			int[] dp = new int[arr.length];
			int max = -1;
			for (int i = 0; i < arr.length; i++) {
				// 每次认为arr[i]单独组成LIS 所以长度为1
				dp[i] = 1;
				for (int j = 0; j < i; j++) {
					// 如果arr[i] > arr[j] 并且能使当前以arr[i]结尾的序列更长
					// 则把arr[i] 根在以arr[j] 结尾的序列后面
					if (arr[i] > arr[j] && dp[i] <= dp[j]) {
						dp[i] = dp[j] + 1;
					}
				}
				max = Math.max(max, dp[i]);
			}
			return max;
		}
	}
```